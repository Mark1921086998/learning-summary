### vue2.0 与 vue3.0 响应式原理

#### 1. vue2.0 响应式原理
    vue2.0 采用的是 数据劫持+发布/订阅模式 的方式，通过 Object.defineProperty() 来劫持各个属性的 setter/getter， 在数据变动时发布消息给订阅者（Wacther）, 触发相应的监听回调
    可以查看 1.vue2数据响应式原理 demo


-    检测不到对象属性的添加和删除：当你在对象上新加了一个属性 newProperty，当前新加的这个属性并没有加入vue检测数据更新的机制(因为是在初始化之后添加的)。vue.$set 是能让 vue 知道你添加了属性, 它会给你做处理，$set 内部也是通过调用 Object.defineProperty() 去处理的
-    无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。
-    当 data 中数据比较多且层级很深的时候，会有性能问题，因为要遍历data中所有的数据并给其设置成响应式的。

总的来说:
    1. 需要响应化的数据较大，递归遍历性能不好、消耗较大
    2. 新增或者删除属性无法监听
    3. 数组响应化需要额外实现
    4. 修改语法有限制

#### 2. vue3.0 响应式原理
    vue3.0 使用了 Proxy 替换了原先遍历对象使用 Object.defineProperty 方法给属性添加 set,get 访问器的笨拙做法
    可以查看 2.vue3数据响应式原理 demo

#####  Proxy
    什么是代理呢，可以理解为在对象之前设置一个“拦截”，当该对象被访问的时候，都必须经过这层拦截。意味着你可以在这层拦截中进行各种操作。比如你可以在这层拦截中对原对象进行处理，返回你想返回的数据结构。

    ES6 原生提供 Proxy 构造函数，MDN上的解释为：Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）

我们先看看是怎么使用的
```javascript
    const p = new Proxy(target, handler)
```
-    target： 所要拦截的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）
-    handler：一个对象，定义要拦截的行为

```javascript
    const p = new Proxy({}, {
        get(target, propKey) {
            return '哈哈，你被我拦截了';
        }
    });

    console.log(p.name);
    // 哈哈，你被我拦截了
```
    注意Proxy是用来操作对象的。代理的目的是为了拓展对象的能力。
    Proxy支持的拦截操作一共 13 种，详细的可以查看 MDN 或者 ES6入门 (我暂时也还没看完)

    vue3.0 用 Proxy 是对对象进行拦截操作，无论是对对象做什么样的操作都会走到 Proxy 的处理逻辑中