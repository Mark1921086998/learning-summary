### 设计模式

#### 什么是设计模式？
> 设计模式是对软件设计开发过程中反复出现的某类问题的通用解决方案。设计模式更多的是指导思想和方法论，而不是现成的代码，当然每种设计模式都有每种语言中的具体实现方式。学习设计模式更多的是理解各种模式的内在思想和解决的问题，毕竟这是前人无数经验总结成的最佳实践，而代码实现则是对加深理解的辅助。
------------------

#### 设计模式的类型
-   设计模式可以分为三大类：
    1. **结构型模式**（Structural Patterns）： 通过识别系统中组件间的简单关系来简化系统的设计。
    2. **创建型模式**（Creational Patterns）： 处理对象的创建，根据实际情况使用合适的方式创建对象。常规的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。
    3. **行为型模式**（Behavioral Patterns）： 用于识别对象之间常见的交互模式并加以实现，如此，增加了这些交互的灵活性。

----------------

### 单例模式
-   **单例模式** （Singleton Pattern）又称为单体模式，保证一个类只有一个实例，并提供一个访问它的全局访问点。也就是说，第二次使用同一个类创建新对象的时候，应该得到与第一次创建的对象完全相同的对象。
    + 通过静态属性创建单例
      ```js
        class Person{
            static instance = null;
            constructor(name){
                if(Person.instance){
                    return Person.instance;
                }
                Person.instance = this;
                this.name = name;
            }
        }
      ```
    + 通过函数创建单例
      ```js
        let instance;
        function createInstance(...arg){
            if(!instance){
                instance = new Game(...arg);
            }
            return instance;
        }
      ```
      + 优：单例模式节约内存开支和实例化时的性能开支，节约性能；
      + 缺：单例模式扩展性不强

### 工厂模式
-   **工厂模式** （Factory Pattern），封装具体实例创建逻辑和过程，外部只需要根据不同条件返回不同的实例。
    - 优点：实现代码复用性，封装良好，抽象逻辑；
    - 缺点：增加了代码复杂程度；

### 装饰者模式
-   **装饰者模式** （Decorator Pattern）使用一种更为灵活的方式来动态给一个对象/函数等添加额外信息
    - 扩展功能 和继承类似
    - 扩展不同类的功能，和原始类并无关联

### 观察者模式（自定义事件）
-   **观察者模式** （Observer Pattern） 定义一个对象与其他对象之间的一种依赖关系，当对象发生某种变化的时候，依赖它的其它对象都会得到更新
    - 自定义事件绑定addEvent
    - 自定义事件触发trigger
    - 自定义事件移除removeEvent